import json
import logging
import sys
from argparse import ArgumentParser, Namespace, RawTextHelpFormatter
from pathlib import Path

import torch
from tqdm import tqdm

from src.logging_config import setup_logging
from src.model import Model
from src.sys_prompt_similarity import compute_sys_prompt_similarity
from src.utils import find_best_candidate_by_rank, set_seed

logging.getLogger('sentence_transformers.SentenceTransformer').setLevel(logging.WARNING)

def get_args() -> Namespace:
    """Parses and validates command-line arguments for the fluency deobfuscation evaluation script."""
    parser = ArgumentParser(
        description="Script for evaluating system prompt deobfuscation.",
        formatter_class=RawTextHelpFormatter
    )
    parser.add_argument(
        "--results_dir",
        type=str,
        required=True,
        help="Path to the directory where obfuscate.py saved its results."
    )
    parser.add_argument(
        "--sys_prompt_list_file",
        type=str,
        required=True,
        help="Path to the file containing system prompts."
    )
    parser.add_argument(
        "--metrics",
        nargs="*",
        choices=["levenshtein", "jaccard", "lcs", "cosine_similarity"],
        default=["levenshtein", "jaccard", "lcs", "cosine_similarity"],
        help="List of metrics to use for evaluation."
    )
    parser.add_argument(
        "--best_candidate_filename",
        type=str,
        default="best_sys_prompt_candidate.pt",
        help="Filename for the output file containing best sys prompt."
    )
    parser.add_argument(
        "--best_candidate_scores_filename",
        type=str,
        default="best_sys_prompt_candidate_scores.json",
        help="Filename for the output file containing best sys prompt scores."
    )
    args = parser.parse_args()
    return args


HIGHER_IS_BETTER = {
    "levenshtein": True,
    "jaccard": True,
    "lcs": True,
    "cosine_similarity": True,
}



def main(
    results_dir: str,
    sys_prompt_list_file: str,
    metrics: list[str],
    best_candidate_filename: str,
    best_candidate_scores_filename: str,
) -> None:
    """
    Evaluates a list of deobfuscated system prompts against the original conventional prompt.

    This script iterates through a list of candidate prompts generated by a deobfuscation
    attack, computes their similarity to the original prompt using string-based metrics,
    identifies the best candidate based on ranked scores, and saves it.

    Args:
        results_dir (str): Path to the directory where the original `obfuscate.py` results are stored.
        sys_prompt_list_file (str): Path to the .pt file containing the list of candidate
                                    deobfuscated system prompt tensors.
        metrics (list[str]): List of string-based similarity metrics to use for evaluation.
        best_candidate_filename (str): Filename for saving the best system prompt tensor.
        best_candidate_scores_filename (str): Filename for saving the scores of the best prompt.
    """
    logger = logging.getLogger(__name__)
    results_dir = Path(results_dir)
    if not results_dir.is_dir():
        logger.error(f"Results directory not found: {results_dir}")
        sys.exit(1)

    params_file = results_dir / "params.json"
    if not params_file.exists():
        logger.error(f"params.json not found in {results_dir}")
        sys.exit(1)
    with open(params_file, "r") as f:
        params = json.load(f)
    logger.info(f"Loaded obfuscation parameters: {json.dumps(params, indent=2)}")

    quantization_mode = None
    if params.get("quantize_4bit", False):
        quantization_mode = "4bit"
    elif params.get("quantize_8bit", False):
        quantization_mode = "8bit"
    
    try:
        model_wrapper = Model(params["model_name"], quantization_mode)
    except Exception as e:
        logger.exception(f"Failed to load model '{params['model_name']}'. Error: {e}")
        return

    logger.info(f"Loaded model: {params['model_name']}")

    set_seed(params["seed"])

    # Load and clean the original, conventional system prompt for comparison
    conventional_sys_prompt = params['system_prompt']
    pad_token_str = model_wrapper.tokenizer.pad_token
    conventional_sys_prompt = conventional_sys_prompt.replace(pad_token_str, "")
    logger.info(f"Reference conventional prompt: '{conventional_sys_prompt}'")

    # Load the list of candidate deobfuscated prompts
    sys_prompt_list = torch.load(sys_prompt_list_file, weights_only=True)

    scores_list = []
    logger.info(f"Finding best system prompt...")
    for sys_prompt in tqdm(sys_prompt_list):
        # Decode the candidate tensor into a string
        sys_prompt_str = model_wrapper.tokenizer.decode(sys_prompt)
        logger.info(f"Testing system prompt: {sys_prompt_str}")
        scores = compute_sys_prompt_similarity(
            sys_prompt_1=conventional_sys_prompt,
            sys_prompt_2=sys_prompt_str,
            metric_list=metrics
        )
        scores_list.append(scores)
        logger.info(f"Sys prompt similarity scores: {scores}")

    # Find the best candidate based on ranked similarity scores
    best_idx, best_scores_dict = find_best_candidate_by_rank(
        candidate_scores=scores_list,
        metric_list=metrics,
        higher_is_better_map=HIGHER_IS_BETTER
    )
    best_sys_prompt = sys_prompt_list[best_idx]
    logger.info(f"Best system promp str: {model_wrapper.tokenizer.decode(best_sys_prompt)}")

    # Save the best candidate tensor and its scores
    logger.info(f"Saving best system prompt to {results_dir / best_candidate_filename}")
    torch.save(best_sys_prompt, results_dir / best_candidate_filename)

    logger.info(f"Saving best system prompt scores to {results_dir / best_candidate_scores_filename}")
    with open(results_dir / best_candidate_scores_filename, "w") as f:
        json.dump(best_scores_dict, f, indent=2)


if __name__ == "__main__":
    setup_logging('evaluate_fluency_deobfuscation.log', 'INFO') # Change to 'DEBUG' for more verbose logging
    logger = logging.getLogger(__name__)

    logger.debug("Parsing command line arguments...")
    try:
        args = get_args()
        logger.info(f"Command line arguments received: {json.dumps(vars(args), indent=2)}")
        main(**vars(args))
    except SystemExit:
        logger.warning("Exiting due to argument parsing issue (e.g., --help or invalid arguments).")
        sys.exit(1)
    except FileNotFoundError as e:
        logger.error(f"A required file was not found: {e}")
        sys.exit(1)
    except Exception as e:
        logger.exception(f"An critical error occurred: {e}")
        sys.exit(1)
    finally:
        logger.info("Done.")